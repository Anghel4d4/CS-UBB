%Dându-se o listă formată din numere întregi, să se genereze ȋn PROLOG lista aranjamentelor cu număr par de elemente,
%având suma număr impar. Se vor scrie modelele matematice și modelele de flux pentru predicatele folosite.
lungime1([],0).
lungime1([_|T],R) :-
    lungime1(T,R1),
    R is R1 + 1.

main1(L,S):-
    lungime1(L,N),
    findall(SS, generare1(L,0,N,0,SS),S).

generare1(_,K,N,SP,[]) :-
    K =< N,
    K mod 2 =:= 0,
    SP mod 2 =:= 1.
generare1(L,K,N,SP,[E|SS]):-
    K =< N,
    candidatC1(E,L),
    eliminatC1(E,L,NL),
    SP1 is SP + E,
    K1 is K + 1,
    generare1(NL,K1,N,SP1,SS).

candidatC1(E,[E|_]).
candidatC1(E,[_|T]) :- candidatC1(E,T).

eliminatC1(_, [], []).
eliminatC1(E, [H|T], [H|R]) :-
    E =\= H,
    eliminatC1(E,T,R).
eliminatC1(E, [E|T],T).


%Să se scrie un program PROLOG care generează lista permutărilor mulţimii 1..N, cu proprietatea că valoarea absolută a
%diferenţei între 2 valori consecutive din permutare este >=2. Se vor scrie modelele matematice și modelele de flux pentru
%predicatele folosite.
%Exemplu- pentru N=4 ⇒ [[3,1,4,2], [2,4,1,3]] (nu neapărat în această ordine)

genereazaN(A,B,[]) :- A > B.
genereazaN(A,B,[A|N]) :- A =< B, A1 is A + 1, genereazaN(A1,B,N).

main2(N,S) :-
    genereazaN(1,N,L),
    findall(SS, generare2(L,N,-N,SS), D),
    eliminaDuplicate(D,S).

cauta(_, []) :- false.
cauta(E, [H|_]) :- 
    E == H,true.
cauta(E, [_|T]) :-
    cauta(E,T).

eliminaDuplicate([],[]).
eliminaDuplicate([H|T],S) :-
    cauta(H,T),
    eliminaDuplicate(T,S).
eliminaDuplicate([H|T],[H|S]) :-
    \+ cauta(H,T),
    eliminaDuplicate(T,S).

generare2(_,0,_,[]).

generare2(L,N,-N,[E|SS]) :-
    N > 0,
    candidat2(E,L),
    eliminare2(E,L,NL),
    N1 is N - 1,
    generare2(NL,N1,E,SS).

generare2(L,N,U,[E|SS]) :-
    N > 0,
    candidat2(E,L),
    eliminare2(E,L,NL),
    abs(E - U) >= 2,
    N1 is N - 1,
    generare2(NL,N1,E,SS).

candidat2(E,[E|_]).
candidat2(E,[_|T]) :- candidat2(E,T).

eliminare2(_,[],[]).
eliminare2(E,[H|T],[H|R]) :- E =\= H, eliminare2(E,T,R).
eliminare2(E,[E|T],T).


%Să se scrie un program PROLOG care generează lista aranjamentelor de  k elemente dintr-o listă de numere întregi, pentru
%care produsul elementelor e mai mic decât o valoare  V dată. Se vor scrie modelele matematice și modelele de flux pentru
%predicatele folosite.
%Exemplu- pentru lista [1, 2, 3], k=2 și V=7 ⇒ [[1,2],[2,1],[1,3],[3,1],[2,3],[3,2]] (nu neapărat în această ordine)

main3(L,K,V,SOL) :-
    findall(S, generare3(L,K,V,1,S),SOL).

generare3(_,0,V,PP,[]) :-
    PP < V.
generare3(L,K,V,ProdusPartial,[E|SOL]) :-
    K > 0,
    candidat3(E,L),
    eliminare3(E,L,NL),
    PP1 is ProdusPartial * E,
    K1 is K - 1,
    generare3(NL,K1,V,PP1,SOL).

candidat3(E, [E|_]).
candidat3(E, [_|T]) :- candidat3(E,T).

eliminare3(_,[],[]).
eliminare3(E,[H|T],[H|R]) :- E =\= H, eliminare3(E,T,R).
eliminare3(E,[E|T],T).


%Să se scrie un program PROLOG care generează lista submulţimilor formate cu elemente unei liste listă de numere întregi,
%având număr suma elementelor număr impar și număr par nenul de elemente pare. Se vor scrie modelele matematice și
%modelele de flux pentru predicatele folosite.
%Exemplu- pentru lista [2,3,4] ⇒ [[2,3,4]]

main4(L,SS) :-
    findall(S,generare4(L,0,0,S),SS).

generare4([],S,C,[]) :-
    S mod 2 =:= 1,
    C mod 2 =:= 0,
    C > 0.
generare4([H|T],S,C,[H|SS]) :-
    S1 is S + H,
    H mod 2 =:= 0,
    C1 is C + 1,
    generare4(T,S1,C1,SS).
generare4([H|T],S,C,[H|SS]) :-
    S1 is S + H,
    H mod 2 =:= 1,
    generare4(T,S1,C,SS).
generare4([_|T],S,C,SS) :-
    generare4(T,S,C,SS).


%Să se scrie un program PROLOG care generează lista submulţimilor de sumă  S dată, cu elementele unei liste, astfel încât
%numărul elementelor pare din submulțime să fie par. Exemplu- pentru lista [1, 2, 3, 4, 5, 6, 10] şi S=10 ⇒ [[1,2,3,4], [4,6]].

main5(L,S,SF) :-
    findall(SS,generare5(L,S,0,0,SS),SF).

generare5([],S,SP,C,[]) :-
    C mod 2 =:= 0,
    SP =:= S.
generare5([H|T],S,SP,C,[H|SS]) :-
    SP1 is SP + H,
    SP1 =< S, 
    H mod 2 =:= 0,
    C1 is C + 1,
    generare5(T,S,SP1,C1,SS).

generare5([H|T],S,SP,C,[H|SS]) :-
    SP1 is SP + H,
    SP1 =< S, 
    H mod 2 =:= 1,
    generare5(T,S,SP1,C,SS).
       
generare5([_|T],S,SP,C,SS) :-
    generare5(T,S,SP,C,SS).

%Să se scrie un program PROLOG care generează lista submulţimilor cu suma număr impar, cu valori din intervalul [a, b]. Se
%vor scrie modelele matematice și modelele de flux pentru predicatele folosite.
%Exemplu- pentru a=2 și b=4 ⇒ [[2,3],[3,4],[2,3,4]] (nu neapărat în această ordine)

genereazaAB(A,B,[]) :- A > B.
genereazaAB(A,B,[A|L]) :- A =< B, A1 is A + 1, genereazaAB(A1,B,L).

main6(A,B,SS) :-
    genereazaAB(A,B,L),
    findall(S,genereaza6(L,0,S),SS).

genereaza6([],S,[]) :-
    S mod 2 =:= 1.
genereaza6([H|T],S,[H|R]) :-
    S1 is S + H,
    genereaza6(T,S1,R).
genereaza6([_|T],S,R) :-
    genereaza6(T,S,R).

%Să se scrie un program PROLOG care generează lista combinărilor de  k elemente cu numere de la 1 la N, având diferența
%între două numere consecutive din combinare număr par. Se vor scrie modelele matematice și modelele de flux pentru
%predicatele folosite.
%Exemplu- pentru N=4, k=2 ⇒ [[1,3],[2,4]] (nu neapărat în această ordine)
genereazaAB7(A,B,[]) :- A > B.
genereazaAB7(A,B,[A|R]) :- A =< B, A1 is A + 1, genereazaAB7(A1,B,R).

main7(N,K,CS) :-
    genereazaAB7(1,N,L),
    findall(S,genereaza7(L,K,N,-N,S),D),
    stergeRep(D,CS).

cauta7([],_) :- false.
cauta7([H|_],E) :-
    H == E,
    true.
cauta7([_|T],E) :-
    cauta7(T,E).

stergeRep([],[]).
stergeRep([H|T],R) :-
    cauta7(T,H),
    stergeRep(T,R).
stergeRep([H|T],[H|R]) :-
    \+ cauta7(T,H),
    stergeRep(T,R).

genereaza7(_,0,_,_,[]).
genereaza7(L,K,N,U,[E|R]):-
    K > 0,
    candidat7(E,L),
    eliminare7(L,E,NL),
    K1 is K - 1,
    U =:= -N,
    genereaza7(NL,K1,N,E,R).

genereaza7(L,K,N,U,[E|R]):-
    K > 0,
    candidat7(E,L),
    eliminare7(L,E,NL),
    K1 is K - 1,
    E > U,
    abs(U - E) mod 2 =:= 0,
    genereaza7(NL,K1,N,E,R).  

candidat7(E,[E|_]).
candidat7(E,[_|T]) :- candidat7(E,T).

eliminare7([],_,[]).
eliminare7([H|T],E,[H|R]) :-
    H =\= E,
    eliminare7(T,E,R).
eliminare7([E|T],E,T).

%Să se scrie un program PROLOG care generează lista submulţimilor formate cu elemente unei liste listă de numere întregi,
%având suma elementelor număr impar și număr impar de elemente impare. Se vor scrie modelele matematice și modelele
%de flux pentru predicatele folosite. 

main8(L,SS):-
    findall(S,generare8(L,0,0,S),SS).

generare8([],S,C,[]) :-
    S mod 2 =:= 1,
    C mod 2 =:= 1.
generare8([H|T],S,C,[H|R]) :-
    S1 is S + H,
    H mod 2 =:= 1,
    C1 is C + 1,
    generare8(T,S1,C1,R).
generare8([H|T],S,C,[H|R]) :-
    S1 is S + H,
    H mod 2 =:= 0,
    generare8(T,S1,C,R).
generare8([_|T],S,C,R) :-
    generare8(T,S,C,R).

%Dându-se o listă formată din numere întregi, să se genereze ȋn PROLOG lista submulţimilor cu număr par de elemente. Se
%vor scrie modelele matematice și modelele de flux pentru predicatele folosite.
%Exemplu- pentru lista L=[2,3,4] ⇒  [[],[2,3],[2,4],[3,4]] (nu neapărat în această ordine)

main9(L,S) :-
    findall(SS,generare9(L,0,SS),S).

generare9([],C,[]) :-
    C mod 2 =:= 0.
generare9([H|T],C,[H|R]) :-
    C1 is C + 1,
    generare9(T,C1,R).
generare9([_|T],C,R) :-
    generare9(T,C,R).

%Dându-se o listă formată din numere întregi, să se genereze ȋn PROLOG lista submulţimilor cu cel puţin N elemente având
%suma divizibilă cu 3. Se vor scrie modelele matematice și modelele de flux pentru predicatele folosite.
%Exemplu- pentru lista L=[2,3,4] și N=1 ⇒  [[3],[2,4],[2,3,4]] (nu neapărat în această ordine)

main10(L, N, Sol) :-
    findall(S, generare10(L,0,N,0,S), Sol).

generare10([],C,N,S,[]) :-
    S mod 3 =:= 0,
    C >= N.
generare10([H|T],C,N,S,[H|R]) :-
    S1 is S + H,
    C1 is C + 1,
    generare10(T,C1,N,S1,R).
generare10([_|T],C,N,S,R) :-
    generare10(T,C,N,S,R).


%C. Să se scrie un program PROLOG care generează lista combinărilor de  k elemente dintr-o listă de numere întregi, având
%suma număr par. Se vor scrie modelele matematice și modelele de flux pentru predicatele folosite.
%Exemplu- pentru lista [6, 5, 3, 4], k=2 ⇒ [[6,4],[5,3]] (nu neapărat în această ordine)

mainX(L,K,S):-
    findall(V,generareX(L,0,K,0,-K,V),S).

generareX(_,C,K,S,_,[]) :-
    C =:= K, S mod 2 =:= 0.
generareX(L,C,K,S,U,[E|V]) :-
    C < K,
    candidatX(E,L),
    eliminareX(L,E,NL),
    C1 is C + 1,
    S1 is S + E,
    U =:= -K,
    generareX(NL,C1,K,S1,E,V).    
generareX(L,C,K,S,U,[E|V]) :-
    C < K,
    candidatX(E,L),
    eliminareX(L,E,NL),
    C1 is C + 1,
    S1 is S + E,
    E < U,
    generareX(NL,C1,K,S1,E,V).

candidatX(E,[E|_]).
candidatX(E,[_|T]) :- candidatX(E,T).

eliminareX([],_,[]).
eliminareX([H|T],E,[H|R]) :- H =\= E, eliminareX(T,E,R).
eliminareX([E|T],E,T).


%C. Scrieţi un program PROLOG care determină dintr-o listă formată din numere întregi lista subşirurilor cu cel puțin 2
%elemente, formate din elemente în ordine strict crescătoare. Se vor scrie modelele matematice și modelele de flux pentru
%predicatele folosite.
%Exemplu- pentru lista  [1, 8, 6, 4] ⇒ [[1,8],[1,6],[1,4],[6,8],[4,8],[4,6],[1,4,6],[1,4,8],[1,6,8],[4,6,8],[1,4,6,8]] (nu
%neapărat în această ordine)

%C. Pentru o valoare  N dată, să se genereze lista permutărilor cu elementele N, N+1,….,2*N-1 având proprietatea că valoarea
%absolută a diferenţei dintre două valori consecutive din permutare este <=2. Se vor scrie modelele matematice și modelele
%de flux pentru predicatele folosite.

genereazaElem(A,B,[]) :- A > B.
genereazaElem(A,B,[A|L]) :- A =< B, A1 is A + 1,genereazaElem(A1,B,L).

main18(N,S) :-
    genereazaElem(N, 2 * N-1,L),
    findall(D,generare18(L,N,-N,D),S).

generare18([],0,_,[]).
generare18(L,N,U,[E|D]) :-
    N > 0,
    candidat18(E,L),
    eliminare18(L,E,NL),
    N1 is N - 1,
    U =:= -N,
    generare18(NL,N1,E,D).

generare18(L,N,U,[E|D]) :-
    N > 0,
    candidat18(E,L),
    eliminare18(L,E,NL),
    N1 is N - 1,
    abs(E - U) =< 2,
    generare18(NL,N1,E,D).

candidat18(E,[E|_]).
candidat18(E,[_|T]) :- candidat18(E,T).

eliminare18([],_,[]).
eliminare18([H|T],E,[H|R]) :- H =\= E, eliminare18(T,E,R).
eliminare18([E|T],E,T).

%C. Dându-se o listă formată din numere întregi, să se genereze ȋn PROLOG lista permutărilor având proprietatea că valoarea
%absolută a diferenţei dintre două valori consecutive din permutare este <=3. Se vor scrie modelele matematice și modelele
%de flux pentru predicatele folosite.
%Exemplu- pentru lista L=[2,7,5] ⇒ [[2,5,7], [7,5,2]] (nu neapărat în această ordine)

lungime19([],0).
lungime19([_|T],R) :- lungime19(T,R1), R is R1 + 1.

main19(L,SS):-
    lungime19(L,N),
    findall(F, generare19(L,N,0,-N,F),SS).

generare19(_,N,C,_,[]) :-
    C =:= N.
generare19(L,N,C,U,[E|D]) :-
    C < N,
    candidat19(E,L),
    eliminare19(L,E,NL),
    C1 is C + 1, 
    U =:= -N,
    generare19(NL,N,C1,E,D).

generare19(L,N,C,U,[E|D]) :-
    C < N,
    candidat19(E,L),
    eliminare19(L,E,NL),
    C1 is C + 1, 
    abs(U - E) =< 3,
    generare19(NL,N,C1,E,D).

candidat19(E,[E|_]).
candidat19(E,[_|T]) :- candidat19(E,T).

eliminare19([],_,[]).
eliminare19([H|T],E,[H|R]) :- H =\= E, eliminare19(T,E,R).
eliminare19([E|T],E,T).

%C. Să se scrie un program PROLOG care generează lista submulţimilor cu  N elemente, cu elementele unei liste, astfel încât
%suma elementelor dintr-o submulțime să fie număr par. Se vor scrie modelele matematice și modelele de flux pentru
%predicatele folosite.
%Exemplu- pentru lista L=[1, 3, 4, 2] şi N=2 ⇒ [[1,3], [2,4]]

main20(L, N, R) :-
    findall(S, generare20(L,N,0,0,S), R).

generare20([], N, S, C, []) :-
    C =:= N,
    S mod 2 =:= 0. 
generare20([H|T], N, S, C, [H|R]) :-
    S1 is S + H,
    C1 is C + 1,
    generare20(T,N,S1,C1,R).
generare20([_|T], N, S, C, R) :-
    generare20(T,N,S,C,R).


%C. Să se scrie un program PROLOG care generează lista aranjamentelor de  k elemente dintr-o listă de numere întregi, având
%produs P dat. Se vor scrie modelele matematice și modelele de flux pentru predicatele folosite.
%Exemplu- pentru lista [2, 5, 3, 4, 10], k=2 şi P=20 ⇒ [[2,10],[10,2],[5,4],[4,5]] (nu neapărat în această ordine)

main21(L,K,P,S) :-
    findall(SS, generare21(L,K,1,P,SS),S).
generare21(_,0,PP,P,[]):-
    PP =:= P.
generare21(L,K,PP,P,[E|SS]):-
    K > 0,
    candidat21(E,L),
    eliminare21(L,E,NL),
    P1 is PP * E,
    K1 is K - 1,
    generare21(NL,K1,P1,P,SS).

candidat21(E,[E|_]).
candidat21(E,[_|T]) :- candidat21(E,T).

eliminare21([],_,[]).
eliminare21([H|T],E,[H|R]) :- H =\= E, eliminare21(T,E,R).
eliminare21([E|T],E,T).

